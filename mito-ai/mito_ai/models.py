from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict, List, Literal, Optional


@dataclass(frozen=True)
class InlineCompletionRequest:
    """Message send by the client to request inline completions.

    Prefix/suffix implementation is used to avoid the need for synchronizing
    the notebook state at every key press.
    """

    message_id: str
    """Message UID generated by the client."""
    prefix: str
    """Text preceding the cursor in the target cell."""
    suffix: str
    """Text following the cursor in the target cell."""
    mime: str
    """media type for the current language, e.g. `text/x-python`"""
    stream: bool
    """Whether to stream the response (if supported by the model)."""
    path: Optional[str] = None
    """Path to the notebook or file for which the completions are generated."""
    language: Optional[str] = None
    """Language of the document, e.g. `python`. It is inferred from the `mime` field."""
    cell_id: Optional[str] = None
    """Cell identifier for the target cell in a notebook."""

    def to_template_inputs(self) -> Dict[str, Any]:
        filename = Path(self.path).name if self.path else "untitled"
        return {
            "prefix": self.prefix,
            "suffix": self.suffix.strip(),
            "language": self.language,
            "filename": filename,
            "stop": ["\n```"],
        }


@dataclass(frozen=True)
class InlineCompletionError:
    """Completion item error information."""

    message: Optional[str] = None
    """Error message."""


@dataclass(frozen=True)
class InlineCompletionItem:
    """The inline completion suggestion to be displayed on the frontend."""

    insertText: str
    """The text to insert into the editor."""
    isIncomplete: Optional[bool] = None
    """Whether the completion is incomplete or not."""
    token: Optional[str] = None
    """Unique token identifying the completion request in the frontend."""
    error: Optional[InlineCompletionError] = None
    """Error information for the completion item."""


@dataclass(frozen=True)
class InlineCompletionList:
    """Reflection of JupyterLab's `IInlineCompletionList`."""

    items: List[InlineCompletionItem]
    """List of completion items."""


@dataclass(frozen=True)
class CompletionError:
    """Completion error description"""

    type: str
    """Error type"""
    title: str
    """Error title"""
    traceback: str
    """Error traceback"""


@dataclass(frozen=True)
class InlineCompletionReply:
    """Message sent from model to client with the inline completion suggestions."""

    list: InlineCompletionList
    """List of completion items."""
    parent_id: str
    """Parent message UID."""
    type: Literal["inline_completion"] = "inline_completion"
    """Message type."""
    error: Optional[CompletionError] = None
    """Completion error."""


@dataclass(frozen=True)
class InlineCompletionStreamChunk:
    """Message sent from model to client with the infill suggestions"""

    response: InlineCompletionItem
    """Completion item."""
    parent_id: str
    """Parent message UID."""
    done: bool
    """Whether the completion is done or not."""
    type: Literal["stream"] = "stream"
    """Message type."""
    error: Optional[CompletionError] = None
    """Completion error."""
