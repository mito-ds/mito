from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict, List, Literal, Optional


@dataclass(frozen=True)
class InlineCompletionRequest:
    """Message send by client to request inline completions.

    Prefix/suffix implementation is used to avoid the need for synchronizing
    the notebook state at every key press (subject to change in future)."""

    number: int
    """Message UID generated by the client to identify replies and to easily discard replies for older requests."""
    prefix: str
    """Text preceding the cursor in the target cell."""
    suffix: str
    """Text following the cursor in the target cell."""
    mime: str
    """media type for the current language, e.g. `text/x-python`"""
    # FIXME drop
    stream: bool
    """Whether to stream the response (if supported by the model)."""
    path: Optional[str] = None
    """Path to the notebook or file for which the completions are generated."""
    language: Optional[str] = None
    """Language of the document, e.g. `python`. It is inferred from the `mime` field."""
    cell_id: Optional[str] = None
    """Cell identifier for the target cell in a notebook."""

    def to_template_inputs(self) -> Dict[str, Any]:
        filename = Path(self.path).name if self.path else "untitled"
        return {
            "prefix": self.prefix,
            "suffix": self.suffix.strip(),
            "language": self.language,
            "filename": filename,
            "stop": ["\n```"],
        }


@dataclass(frozen=True)
class InlineCompletionError:
    message: Optional[str] = None


@dataclass(frozen=True)
class InlineCompletionItem:
    """The inline completion suggestion to be displayed on the frontend.

    See JupyterLab `InlineCompletionItem` documentation for the details.
    """

    insertText: str
    filterText: Optional[str] = None
    isIncomplete: Optional[bool] = None
    token: Optional[str] = None
    error: Optional[InlineCompletionError] = None


@dataclass(frozen=True)
class InlineCompletionList:
    """Reflection of JupyterLab's `IInlineCompletionList`."""

    items: List[InlineCompletionItem]


@dataclass(frozen=True)
class CompletionError:
    type: str
    title: str
    traceback: str


@dataclass(frozen=True)
class InlineCompletionReply:
    """Message sent from model to client with the infill suggestions"""

    list: InlineCompletionList
    # number of request for which we are replying
    reply_to: int
    type: Literal["inline_completion"] = "inline_completion"
    error: Optional[CompletionError] = None


@dataclass(frozen=True)
class InlineCompletionStreamChunk:
    """Message sent from model to client with the infill suggestions"""

    response: InlineCompletionItem
    reply_to: int
    done: bool
    type: Literal["stream"] = "stream"
    error: Optional[CompletionError] = None
