{
  "slug": [
    "functions",
    "lookup",
    "ADDRESS"
  ],
  "functionNameShort": "ADDRESS",
  "functionNameLong": "Address",
  "relatedFunctions": [
    "INDIRECT"
  ],
  "purpose": "Return cell address as text given row/column",
  "titleCardParagraphs": [
    "Excel's ADDRESS function: Return cell address as text given row/column.",
    "This guide explains in depth how to replicate Excel's ADDRESS functionality in Python using pandas and numpy.",
    "We will cover syntax, multiple examples, edge cases, performance considerations, common mistakes, and best practices."
  ],
  "excelExplanation": {
    "paragraphs": [
      "The ADDRESS function in Excel allows users to return cell address as text given row/column.",
      "Syntax and parameters are flexible, allowing for optional arguments and different modes of operation.",
      "=ADDRESS(row_num,column_num)",
      "Excel formulas can be combined with other functions, making this versatile in reporting and analysis."
    ],
    "syntaxTable": [
      {
        "parameter": "row_num",
        "description": "Row number",
        "dataType": "number"
      }
    ],
    "examplesTable": [
      {
        "formula": "=ADDRESS(1,1)",
        "description": "Return $A$1",
        "result": "$A$1"
      },
      {
        "formula": "=ADDRESS(...)",
        "description": "Another common example of ADDRESS in practice.",
        "result": "Result depending on context"
      }
    ]
  },
  "equivalentCode": {
    "introParagraphs": [
      "To mimic Excel's ADDRESS in pandas, you can use several approaches depending on context.",
      "Below are multiple strategies, each with pros and cons.",
      "These code examples also illustrate performance differences and how to handle missing data."
    ],
    "codeSections": [
      {
        "title": "Basic usage in pandas",
        "shortTitle": "basic",
        "paragraphs": [
          "Simple equivalent of ADDRESS using core pandas methods.",
          "Useful for small datasets and straightforward logic."
        ],
        "codeLines": [
          "import pandas as pd",
          "df = pd.DataFrame({'A':[10,20], 'B':[30,40]})",
          "row, col = 1, 2  # Excel is 1-based",
          "val = df.iloc[row-1, col-1]",
          "cell_address = f\"${chr(64+col)}${row}\"",
          "print(cell_address, val)"
        ]
      },
      {
        "title": "Alternative using numpy",
        "shortTitle": "numpy",
        "paragraphs": [
          "For performance-sensitive tasks, numpy can be faster than pandas.",
          "This approach is vectorized and avoids Python loops."
        ],
        "codeLines": [
          "def col_letters(n):",
          "    s=''",
          "    while n>0:",
          "        n, r = divmod(n-1, 26)",
          "        s = chr(65+r)+s",
          "    return s",
          "print(f\"${col_letters(28)}$15\")  # $AB$15"
        ]
      },
      {
        "title": "Advanced usage",
        "shortTitle": "advanced",
        "paragraphs": [
          "For complex business logic, combine pandas, numpy, and custom functions.",
          "This is useful when porting long Excel formulas into maintainable Python code."
        ],
        "codeLines": [
          "import re, pandas as pd",
          "def address_to_iloc(addr):",
          "    m = re.match(r\"\\$?([A-Z]+)\\$?(\\d+)\", addr)",
          "    col, row = m.group(1), int(m.group(2))",
          "    # convert letters to 1-based number",
          "    n=0",
          "    for ch in col: n = n*26 + (ord(ch)-64)",
          "    return (row-1, n-1)",
          "",
          "print(address_to_iloc('$B$2'))  # (1,1)"
        ]
      }
    ]
  },
  "commonMistakes": {
    "introParagraphs": [
      "Here are common mistakes when replicating Excel logic in pandas:",
      "These include indexing errors, type mismatches, handling NaN values, and misinterpreting Excel defaults.",
      "We provide at least three examples for clarity."
    ],
    "codeSections": [
      {
        "title": "Indexing differences",
        "shortTitle": "0 vs 1 based",
        "paragraphs": [
          "Excel uses 1-based indexing, pandas uses 0-based."
        ],
        "codeLines": [
          "# Excel is 1-based, pandas iloc is 0-based:",
          "import pandas as pd",
          "df = pd.DataFrame({'A':[10,20], 'B':[30,40]})",
          "excel_row, excel_col = 2, 2  # B2",
          "value = df.iloc[excel_row-1, excel_col-1]",
          "print(value)"
        ]
      },
      {
        "title": "Type coercion issues",
        "shortTitle": "types",
        "paragraphs": [
          "Excel coerces types differently than pandas."
        ],
        "codeLines": [
          "import pandas as pd",
          "df = pd.DataFrame({'num':['10','20','x']})",
          "df['num_num'] = pd.to_numeric(df['num'], errors='coerce')",
          "print(df)"
        ]
      },
      {
        "title": "NA handling",
        "shortTitle": "NaN",
        "paragraphs": [
          "Excel ignores blanks, pandas uses NaN."
        ],
        "codeLines": [
          "import pandas as pd",
          "df = pd.DataFrame({'A':[1,None,3]})",
          "print(df['A'].fillna(0))  # Excel often treats blanks as 0 in some functions"
        ]
      },
      {
        "title": "Performance assumptions",
        "shortTitle": "large data",
        "paragraphs": [
          "Excel is fine with small datasets, pandas/numpy scale better for large data."
        ],
        "codeLines": [
          "import pandas as pd",
          "df = pd.DataFrame({'A': range(1_000)})",
          "# Avoid row-wise loops:",
          "total_loop = 0",
          "for _, r in df.iterrows():",
          "    total_loop += r['A']",
          "# Prefer vectorization:",
          "total_vec = df['A'].sum()",
          "print(total_vec)"
        ]
      }
    ]
  }
}