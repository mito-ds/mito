name: Deploy - Mito Metapackage
on:
  schedule:
    # Run daily at 10:00 UTC to check for new versions
    - cron: '0 10 * * *'
  workflow_dispatch:
    # Allow manual triggering
    inputs:
      force_deploy:
        description: 'Force deploy even if no version changes detected'
        required: false
        default: false
        type: boolean

jobs:
  check-and-deploy:
    name: Check versions and deploy metapackage
    runs-on: ubuntu-24.04
    strategy:
      matrix:
        python-version: [3.11]
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
          
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests toml build twine hatchling
          
      - name: Setup Auth for PyPi
        run: |
          echo -e "[distutils]" >> ~/.pypirc
          echo -e "index-servers =" >> ~/.pypirc
          echo -e "    pypi" >> ~/.pypirc
          echo -e "    testpypi" >> ~/.pypirc
          echo -e "[pypi]" >> ~/.pypirc
          echo -e "repository = https://upload.pypi.org/legacy/" >> ~/.pypirc
          echo -e "username = __token__" >> ~/.pypirc
          echo -e "password = ${{ secrets.PYPI_API_TOKEN }}" >> ~/.pypirc
          echo -e "" >> ~/.pypirc
          echo -e "[testpypi]" >> ~/.pypirc
          echo -e "repository = https://test.pypi.org/legacy/" >> ~/.pypirc
          echo -e "username = __token__" >> ~/.pypirc
          echo -e "password = ${{ secrets.TEST_PYPI_API_TOKEN }}" >> ~/.pypirc
          
      - name: Check for version updates and deploy
        run: |
          cd mito
          python << 'EOF'
          import requests
          import toml
          import subprocess
          import sys
          from datetime import datetime
          import os
          
          def get_latest_pypi_version(package_name):
              """Get the latest version of a package from PyPI."""
              try:
                  response = requests.get(f"https://pypi.org/pypi/{package_name}/json")
                  response.raise_for_status()
                  return response.json()["info"]["version"]
              except Exception as e:
                  print(f"Error fetching version for {package_name}: {e}")
                  return None
          
          def parse_version_constraint(constraint):
              """Parse version constraint like '>=0.1.20' to get the minimum version."""
              if ">=" in constraint:
                  return constraint.split(">=")[1].strip()
              elif ">" in constraint:
                  return constraint.split(">")[1].strip()
              elif "==" in constraint:
                  return constraint.split("==")[1].strip()
              return constraint.strip()
          
          def generate_calver():
              """Generate CalVer version in YYYY.MM format."""
              now = datetime.now()
              base_version = f"{now.year}.{now.month:02d}"
              
              # Check if this version already exists on PyPI
              try:
                  response = requests.get("https://pypi.org/pypi/mito/json")
                  if response.status_code == 200:
                      existing_versions = list(response.json()["releases"].keys())
                      # Find if base version exists and get next patch number
                      patch_versions = [v for v in existing_versions if v.startswith(base_version)]
                      if patch_versions:
                          # Find highest patch number
                          max_patch = 0
                          for v in patch_versions:
                              parts = v.split('.')
                              if len(parts) == 3 and parts[2].isdigit():
                                  max_patch = max(max_patch, int(parts[2]))
                              elif len(parts) == 2:
                                  max_patch = max(max_patch, 0)
                          return f"{base_version}.{max_patch + 1}"
              except:
                  pass
              
              return base_version
          
          # Load current pyproject.toml
          with open("pyproject.toml", "r") as f:
              config = toml.load(f)
          
          # Get current dependencies
          current_deps = config["project"]["dependencies"]
          
          # Parse current versions
          current_versions = {}
          for dep in current_deps:
              if "mito-ai" in dep:
                  current_versions["mito-ai"] = parse_version_constraint(dep.split(">=")[1] if ">=" in dep else dep)
              elif "mitosheet" in dep:
                  current_versions["mitosheet"] = parse_version_constraint(dep.split(">=")[1] if ">=" in dep else dep)
          
          print(f"Current versions: {current_versions}")
          
          # Get latest versions from PyPI
          latest_versions = {}
          latest_versions["mito-ai"] = get_latest_pypi_version("mito-ai")
          latest_versions["mitosheet"] = get_latest_pypi_version("mitosheet")
          
          print(f"Latest versions: {latest_versions}")
          
          # Check if update is needed
          needs_update = False
          force_deploy = "${{ inputs.force_deploy }}" == "true"
          
          if force_deploy:
              print("Force deploy requested")
              needs_update = True
          else:
              for package in ["mito-ai", "mitosheet"]:
                  if latest_versions[package] and current_versions.get(package) != latest_versions[package]:
                      print(f"{package}: {current_versions.get(package)} -> {latest_versions[package]}")
                      needs_update = True
          
          if not needs_update:
              print("No updates needed. Exiting.")
              sys.exit(0)
          
          # Update dependencies and version
          new_deps = []
          for package in ["mito-ai", "mitosheet"]:
              if latest_versions[package]:
                  new_deps.append(f"{package}>={latest_versions[package]}")
              else:
                  # Keep current constraint if we couldn't fetch latest
                  for dep in current_deps:
                      if package in dep:
                          new_deps.append(dep)
                          break
          
          config["project"]["dependencies"] = new_deps
          config["project"]["version"] = generate_calver()
          
          print(f"New version: {config['project']['version']}")
          print(f"New dependencies: {new_deps}")
          
          # Write updated pyproject.toml
          with open("pyproject.toml", "w") as f:
              toml.dump(config, f)
          
          # Set environment variable for next steps
          with open(os.environ['GITHUB_ENV'], 'a') as f:
              f.write(f"NEW_VERSION={config['project']['version']}\n")
              f.write("SHOULD_DEPLOY=true\n")
          EOF
          
      - name: Build and deploy metapackage
        if: env.SHOULD_DEPLOY == 'true'
        run: |
          cd mito
          echo "Building metapackage version $NEW_VERSION"
          
          # Clean previous builds
          rm -rf dist/
          
          # Build the package
          python -m build --sdist --wheel
          
          # Deploy to PyPI
          twine upload dist/*
          
          echo "Successfully deployed mito metapackage version $NEW_VERSION"
          
      - name: Commit version changes
        if: env.SHOULD_DEPLOY == 'true'
        run: |
          cd mito
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add pyproject.toml
          git commit -m "chore: bump metapackage to version $NEW_VERSION" || exit 0
          git push 